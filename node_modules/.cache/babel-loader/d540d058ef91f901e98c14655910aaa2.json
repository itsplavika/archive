{"ast":null,"code":"// import 'abortcontroller-polyfill/dist/polyfill-patch-fetch';\nimport { all, call, take, race, delay, fork, cancelled, select } from 'redux-saga/effects';\nimport actionsTypes from '../actions/types';\nimport { createRequestInstance } from 'redux-saga-requests';\nimport { workflowSagas } from './workflow';\nimport { workOrderSagas } from './workOrder';\nimport { workRequestV2Sagas } from './workRequestV2';\nimport { equipmentLocationsSagas } from './equipmentLocations';\nimport { assetsSagas } from './assets';\nimport { createDriver } from 'redux-saga-requests-fetch';\nimport { APIException } from './api';\nimport { onRequestSaga, onSuccessSaga, onAbortSaga } from './api/requestInterceptors';\nimport { request, gql } from 'graphql-request';\nimport { AppSettings } from '../utils/appSettings';\nimport { selectors } from '../reducers';\nexport const CANCELLED_REQ = {\n  status: 'Cancelled',\n  message: 'Cancelled request'\n};\nexport function* allSagas() {\n  yield all([...workflowSagas, ...equipmentLocationsSagas, ...assetsSagas, ...workOrderSagas, ...workRequestV2Sagas]);\n} //TODO Dummy\n\nconst LOGOUT_PATH = '/logout';\nexport function* requestCleanup(path, reqMethod) {// yield cancelled is true when the saga gets cancelled\n  // lets perform some cleanup here by completing any ongoing requests\n}\nexport function* apiCallWithRetry(args) {\n  const {\n    query,\n    gCtxtCmp = 'workRequest',\n    timeout = 3 * 60 * 1000,\n    opts\n  } = args;\n  const path = AppSettings.API_URL; // const apiRequestAction = {\n  //   type: 'API_WATCHER',\n  //   request: { url: path, args },\n  // };\n\n  try {\n    let apiResp;\n    let logout;\n    let timeoutEffect; // const token = state?.workrequest?.authContext?.accessToken || AppSettings.TEST_TOKEN;\n\n    let token = yield select(selectors.userToken);\n\n    if (!token) {\n      token = AppSettings.TEST_TOKEN;\n    }\n\n    if (path !== LOGOUT_PATH) {\n      ({\n        apiResp,\n        logout,\n        timeoutEffect\n      } = yield race({\n        apiResp: call(request, path, gql`${query}`, undefined, {\n          Authorization: `Bearer ${token}`,\n          g_ctxt_cmp: gCtxtCmp,\n          g_ctxt_lang: 1,\n          g_ctxt_ou: 2,\n          g_ctxt_role: \"testrole\"\n        }),\n        logout: take(actionsTypes.USER_LOGOUT),\n        timeoutEffect: delay(timeout)\n      }));\n    } else {// apiResp = yield call(sendRequest, apiRequestAction, {\n      //   dispatchRequestAction: false,\n      // });\n    }\n\n    if (timeoutEffect) {\n      yield call(requestCleanup, path, opts === null || opts === void 0 ? void 0 : opts.method);\n      throw new APIException(CANCELLED_REQ);\n    } // logout effect succeeded then the apiResp would be undefined\n\n\n    if (logout) {\n      return null;\n    }\n\n    return apiResp || {};\n  } finally {\n    if (yield cancelled()) {\n      yield call(requestCleanup, path, opts === null || opts === void 0 ? void 0 : opts.method);\n    }\n  }\n}\nexport default function* rootSaga() {\n  yield createRequestInstance({\n    driver: createDriver(window.fetch, {\n      // AbortController Not supported in IE installed this polyfill package\n      // that it would resort to\n      // TODO: Have to check if it works in an IE explorer\n      AbortController: window.AbortController\n    }),\n    onRequest: onRequestSaga,\n    onSuccess: onSuccessSaga,\n    onAbort: onAbortSaga\n  });\n  yield fork(allSagas); // const {logout} = yield race({\n  //   logout: take(Abort all saga actions),\n  // });\n  // stop the main sagas\n  // t.cancel();\n}","map":{"version":3,"sources":["/Users/plsingh/Downloads/archive-19Sep-Sunday/src/sagas/index.js"],"names":["all","call","take","race","delay","fork","cancelled","select","actionsTypes","createRequestInstance","workflowSagas","workOrderSagas","workRequestV2Sagas","equipmentLocationsSagas","assetsSagas","createDriver","APIException","onRequestSaga","onSuccessSaga","onAbortSaga","request","gql","AppSettings","selectors","CANCELLED_REQ","status","message","allSagas","LOGOUT_PATH","requestCleanup","path","reqMethod","apiCallWithRetry","args","query","gCtxtCmp","timeout","opts","API_URL","apiResp","logout","timeoutEffect","token","userToken","TEST_TOKEN","undefined","Authorization","g_ctxt_cmp","g_ctxt_lang","g_ctxt_ou","g_ctxt_role","USER_LOGOUT","method","rootSaga","driver","window","fetch","AbortController","onRequest","onSuccess","onAbort"],"mappings":"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","sourcesContent":["// import 'abortcontroller-polyfill/dist/polyfill-patch-fetch';\nimport {\n  all,\n  call,\n  take,\n  race,\n  delay,\n  fork,\n  cancelled,\n  select,\n} from 'redux-saga/effects';\nimport actionsTypes from '../actions/types'\nimport { createRequestInstance } from 'redux-saga-requests';\nimport { workflowSagas } from './workflow';\nimport { workOrderSagas } from './workOrder';\nimport { workRequestV2Sagas } from './workRequestV2';\nimport { equipmentLocationsSagas } from './equipmentLocations';\nimport { assetsSagas } from './assets';\n\nimport { createDriver } from 'redux-saga-requests-fetch';\nimport { APIException } from './api';\nimport { onRequestSaga, onSuccessSaga, onAbortSaga } from './api/requestInterceptors'\nimport { request, gql } from 'graphql-request'\nimport { AppSettings } from '../utils/appSettings';\nimport { selectors } from '../reducers';\n\nexport const CANCELLED_REQ = {\n  status: 'Cancelled',\n  message: 'Cancelled request',\n};\n\nexport function* allSagas() {\n  yield all([\n    ...workflowSagas,\n    ...equipmentLocationsSagas,\n    ...assetsSagas,\n    ...workOrderSagas,\n    ...workRequestV2Sagas\n  ]);\n}\n\n//TODO Dummy\nconst LOGOUT_PATH = '/logout'\n\nexport function* requestCleanup(path, reqMethod) {\n  // yield cancelled is true when the saga gets cancelled\n  // lets perform some cleanup here by completing any ongoing requests\n}\n\n\nexport function* apiCallWithRetry(args) {\n  const { query, gCtxtCmp = 'workRequest', timeout = 3 * 60 * 1000, opts } = args;\n  const path = AppSettings.API_URL;\n  // const apiRequestAction = {\n  //   type: 'API_WATCHER',\n  //   request: { url: path, args },\n\n  // };\n\n  try {\n    let apiResp;\n    let logout;\n    let timeoutEffect;\n    // const token = state?.workrequest?.authContext?.accessToken || AppSettings.TEST_TOKEN;\n    let token = yield select(selectors.userToken);\n    if(!token){\n      token = AppSettings.TEST_TOKEN;\n    }\n    if (path !== LOGOUT_PATH) {\n      ({ apiResp, logout, timeoutEffect } = yield race({\n        apiResp: call(request, path, gql`${query}`, undefined, {\n          Authorization: `Bearer ${token}`,\n          g_ctxt_cmp: gCtxtCmp,\n          g_ctxt_lang: 1,\n          g_ctxt_ou: 2,\n          g_ctxt_role: \"testrole\"\n        }),\n        logout: take(actionsTypes.USER_LOGOUT),\n        timeoutEffect: delay(timeout),\n      }));\n    } else {\n      // apiResp = yield call(sendRequest, apiRequestAction, {\n      //   dispatchRequestAction: false,\n      // });\n    }\n\n    if (timeoutEffect) {\n      yield call(requestCleanup, path, opts?.method);\n\n      throw new APIException(CANCELLED_REQ);\n    }\n\n    // logout effect succeeded then the apiResp would be undefined\n\n    if (logout) { return null; }\n\n    return apiResp || {};\n  } finally {\n    if (yield cancelled()) {\n      yield call(requestCleanup, path, opts?.method);\n    }\n  }\n}\n\nexport default function* rootSaga() {\n  yield createRequestInstance({\n    driver: createDriver(window.fetch, {\n      // AbortController Not supported in IE installed this polyfill package\n      // that it would resort to\n      // TODO: Have to check if it works in an IE explorer\n      AbortController: window.AbortController,\n    }),\n    onRequest: onRequestSaga,\n    onSuccess: onSuccessSaga,\n    onAbort: onAbortSaga,\n  });\n  yield fork(allSagas);\n  // const {logout} = yield race({\n  //   logout: take(Abort all saga actions),\n  // });\n\n  // stop the main sagas\n  // t.cancel();\n}\n"]},"metadata":{},"sourceType":"module"}