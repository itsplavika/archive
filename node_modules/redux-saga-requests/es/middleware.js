import _extends from "@babel/runtime/helpers/extends";
import { GET_REQUEST_CACHE, CLEAR_REQUESTS_CACHE } from './constants';
import { success, isRequestAction, isSuccessAction, isResponseAction, getRequestActionFromResponse, getActionPayload } from './actions';

var shouldActionBePromisified = function shouldActionBePromisified(action, auto) {
  return auto && !(action.meta && action.meta.asPromise === false) || action.meta && action.meta.asPromise;
};

export var requestsPromiseMiddleware = function requestsPromiseMiddleware(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$auto = _ref.auto,
      auto = _ref$auto === void 0 ? false : _ref$auto;

  var requestMap = new Map();
  return function () {
    return function (next) {
      return function (action) {
        if (isRequestAction(action) && shouldActionBePromisified(action, auto)) {
          return new Promise(function (resolve, reject) {
            requestMap.set(action, function (response, error) {
              return error ? reject(response) : resolve(response);
            });
            next(action);
          });
        }

        if (isResponseAction(action)) {
          var requestAction = getRequestActionFromResponse(action);

          if (shouldActionBePromisified(requestAction, auto)) {
            var requestActionPromise = requestMap.get(requestAction);
            requestActionPromise(action, action.type !== success(requestAction.type));
            requestMap.delete(requestAction);
          }
        }

        return next(action);
      };
    };
  };
};

var isCacheValid = function isCacheValid(cache) {
  return cache.expiring === null || Date.now() <= cache.expiring;
};

var getNewCacheTimeout = function getNewCacheTimeout(cache) {
  return cache === true ? null : cache * 1000 + Date.now();
};

var getCacheKey = function getCacheKey(action) {
  return action.type + (action.meta.cacheKey || '');
};

export var requestsCacheMiddleware = function requestsCacheMiddleware() {
  var cacheMap = new Map();
  return function () {
    return function (next) {
      return function (action) {
        if (action.type === GET_REQUEST_CACHE) {
          return cacheMap;
        }

        if (action.type === CLEAR_REQUESTS_CACHE) {
          if (action.actionTypes.length === 0) {
            cacheMap.clear();
          } else {
            action.actionTypes.forEach(function (actionType) {
              return cacheMap.delete(actionType);
            });
          }

          return null;
        }

        if (isRequestAction(action) && action.meta && action.meta.cache) {
          var cacheKey = getCacheKey(action);
          var cacheValue = cacheMap.get(cacheKey);

          if (cacheValue && isCacheValid(cacheValue)) {
            return next(_extends({}, action, {
              meta: _extends({}, action.meta, {
                cacheResponse: cacheValue.response
              })
            }));
          } else if (cacheValue && !isCacheValid(cacheValue)) {
            cacheMap.delete(cacheKey);
          }
        } else if (isSuccessAction(action) && action.meta && action.meta.cache && !action.meta.cacheResponse) {
          var requestAction = getRequestActionFromResponse(action);

          if (action.meta.cacheKey && action.meta.cacheSize) {
            var currentCacheKeys = Array.from(cacheMap.keys()).filter(function (k) {
              return k.startsWith(requestAction.type);
            });

            if (action.meta.cacheSize === currentCacheKeys.length) {
              cacheMap.delete(currentCacheKeys[0]);
            }
          }

          cacheMap.set(getCacheKey(requestAction), {
            response: getActionPayload(action).response,
            expiring: getNewCacheTimeout(action.meta.cache)
          });
        }

        return next(action);
      };
    };
  };
};
export var serverRequestsFilterMiddleware = function serverRequestsFilterMiddleware(_ref2) {
  var serverRequestActions = _ref2.serverRequestActions;
  var actionsToBeIgnored = serverRequestActions.slice();
  return function () {
    return function (next) {
      return function (action) {
        if (!isRequestAction(action)) {
          return next(action);
        }

        var actionToBeIgnoredIndex = actionsToBeIgnored.findIndex(function (a) {
          return a.type === action.type;
        });

        if (actionToBeIgnoredIndex === -1) {
          return next(action);
        }

        actionsToBeIgnored.splice(actionToBeIgnoredIndex, 1);
        return null;
      };
    };
  };
};